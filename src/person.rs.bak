extern crate sfml;

use self::sfml::system::Time;
use self::sfml::graphics::{Color, Texture, Sprite, CircleShape, RenderWindow, RenderTarget};
use self::sfml::system::Vector2f;

use entity::Entity;
use physicsobj::PhysicsObj;

struct PhysicsObj {
    radius: f64,
    theta: f64,
    omega: f64,
    acceleration_x: f64,
    acceleration_y: f64,
    velocity_x: f64,
    velocity_y: f64,
    v0_x: f64,
    v0_y: f64,
}

impl PhysicsObj {
    pub fn new(radius: f64, theta: f64, omega: f64, acceleration: f64) -> PhysicsObj {
        PhysicsObj {
            radius: radius,
            theta: theta,
            omega: omega,
            acceleration_x: acceleration,
            acceleration_y: acceleration,
            velocity_x: omega*radius/theta.cos(),
            v0_x: omega*radius/theta.cos(),
            velocity_y: omega*radius/theta.sin(),
            v0_y: omega*radius/theta.sin(),
        }
    }

    pub fn get_x(&self) -> f64 {
        self.radius * self.theta.cos()
    }

    pub fn get_y(&self) -> f64 {
        self.radius * self.theta.sin()
    }

    pub fn set_coords(&mut self, x: f64, y: f64) {
        self.radius = (x*x+y*y).sqrt();
        self.theta = (y/x).atan();
    }
}

pub struct Person {
    feet: PhysicsObj,
    rmax: f64,
}

impl Person {
    pub fn new(feet_x: f64, feet_y: f64, omega: f64, rmax: f64) -> Person {
        let mut feet = PhysicsObj::new(
            (feet_x*feet_x+feet_y*feet_y).sqrt(),
            (feet_y/feet_x).atan(),
            omega,
            0.0
            );
        Person {
            feet: feet,
            rmax: rmax,
        }
    }
}

impl Entity for Person {
    fn update(&mut self, t: &Time) {
        //self.feet.theta = self.feet.omega * t.as_seconds() as f64;
        if(self.feet.radius >= self.rmax) {
            self.feet.acceleration_x = -(self.feet.omega*self.feet.omega) * self.feet.get_x();
            self.feet.acceleration_y = -(self.feet.omega*self.feet.omega) * self.feet.get_y();
        }
        else {
            self.feet.acceleration_x = 0.0;
            self.feet.acceleration_y = 0.0;
        }
        self.feet.velocity_x = self.feet.v0_x + self.feet.acceleration_x * t.as_seconds() as f64;
        self.feet.velocity_y = self.feet.v0_y + self.feet.acceleration_y * t.as_seconds() as f64;
        let mut x = self.feet.velocity_x * t.as_seconds() as f64;
        let mut y = self.feet.velocity_y * t.as_seconds() as f64;
        self.feet.set_coords(x,y);
        println!("X: {}, Y: {}", x, y);
    }
    fn draw(&self, target: &mut RenderWindow) {
        let mut ballkugel = CircleShape::new_init(20.0, 16).unwrap();
        ballkugel.set_origin2f(20.0,20.0);
        ballkugel.set_position2f(self.feet.get_x() as f32, self.feet.get_y() as f32);
        ballkugel.set_fill_color(&Color::cyan());
        target.draw(&ballkugel);
    }
}
